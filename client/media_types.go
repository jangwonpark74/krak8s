// Code generated by goagen v1.2.0-dirty, DO NOT EDIT.
//
// API "krak8s": Application Media Types
//
// Command:
// $ goagen
// --design=krak8s/design
// --out=$(GOPATH)/src/krak8s
// --version=v1.2.0-dirty

package client

import (
	"github.com/goadesign/goa"
	"net/http"
	"time"
	"unicode/utf8"
)

// Application representation type (default view)
//
// Identifier: application/application+json; view=default
type Application struct {
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexadecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// Application name
	Name string `form:"name" json:"name" xml:"name"`
	// The related namespace's generated unique id, not the namespace's name
	NamespaceID string `form:"namespace_id" json:"namespace_id" xml:"namespace_id"`
	Status      *struct {
		// Last deployment time
		DeployedAt time.Time `form:"deployed_at" json:"deployed_at" xml:"deployed_at"`
		// Application specific notification / statuses / notes (if any)
		Notes *string `form:"notes,omitempty" json:"notes,omitempty" xml:"notes,omitempty"`
		// Deployment state
		State string `form:"state" json:"state" xml:"state"`
	} `form:"status" json:"status" xml:"status"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
	// Date of last update
	UpdatedAt time.Time `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// Application version
	Version string `form:"version" json:"version" xml:"version"`
}

// Validate validates the Application media type instance.
func (mt *Application) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if mt.Version == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "version"))
	}
	if mt.Status == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "status"))
	}
	if mt.NamespaceID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "namespace_id"))
	}

	if mt.Status != nil {

		if mt.Status.State == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.status`, "state"))
		}
		if !(mt.Status.State == "UNKNOWN" || mt.Status.State == "DEPLOYED" || mt.Status.State == "DELETED" || mt.Status.State == "SUPERSEDED" || mt.Status.State == "FAILED" || mt.Status.State == "DELETING") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status.state`, mt.Status.State, []interface{}{"UNKNOWN", "DEPLOYED", "DELETED", "SUPERSEDED", "FAILED", "DELETING"}))
		}
	}
	return
}

// DecodeApplication decodes the Application instance encoded in resp body.
func (c *Client) DecodeApplication(resp *http.Response) (*Application, error) {
	var decoded Application
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// An application object reference by object id (oid), and url (default view)
//
// Identifier: application/application.ref+json; view=default
type ApplicationRef struct {
	// The application resource unique oid
	Oid string `form:"oid" json:"oid" xml:"oid"`
	// url of the collection that contains this object
	URL string `form:"url" json:"url" xml:"url"`
}

// Validate validates the ApplicationRef media type instance.
func (mt *ApplicationRef) Validate() (err error) {
	if mt.Oid == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "oid"))
	}
	if mt.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	return
}

// DecodeApplicationRef decodes the ApplicationRef instance encoded in resp body.
func (c *Client) DecodeApplicationRef(resp *http.Response) (*ApplicationRef, error) {
	var decoded ApplicationRef
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ApplicationRefCollection is the media type for an array of ApplicationRef (default view)
//
// Identifier: application/application.ref+json; type=collection; view=default
type ApplicationRefCollection []*ApplicationRef

// Validate validates the ApplicationRefCollection media type instance.
func (mt ApplicationRefCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeApplicationRefCollection decodes the ApplicationRefCollection instance encoded in resp body.
func (c *Client) DecodeApplicationRefCollection(resp *http.Response) (ApplicationRefCollection, error) {
	var decoded ApplicationRefCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// ApplicationCollection is the media type for an array of Application (default view)
//
// Identifier: application/application+json; type=collection; view=default
type ApplicationCollection []*Application

// Validate validates the ApplicationCollection media type instance.
func (mt ApplicationCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeApplicationCollection decodes the ApplicationCollection instance encoded in resp body.
func (c *Client) DecodeApplicationCollection(resp *http.Response) (ApplicationCollection, error) {
	var decoded ApplicationCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Cluster resource representation type (default view)
//
// Identifier: application/cluster+json; view=default
type Cluster struct {
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexadecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// The related namespace's generated unique id, not the namespace's name
	NamespaceID string `form:"namespace_id" json:"namespace_id" xml:"namespace_id"`
	// Requested node pool size
	NodePoolSize int `form:"nodePoolSize" json:"nodePoolSize" xml:"nodePoolSize"`
	// Lifecycle state
	State string `form:"state" json:"state" xml:"state"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
	// Date of last update
	UpdatedAt time.Time `form:"updated_at" json:"updated_at" xml:"updated_at"`
}

// Validate validates the Cluster media type instance.
func (mt *Cluster) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if mt.State == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "state"))
	}
	if mt.NamespaceID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "namespace_id"))
	}
	if !(mt.State == "create_requested" || mt.State == "starting" || mt.State == "active" || mt.State == "delete_requested" || mt.State == "deleting" || mt.State == "deleted") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.state`, mt.State, []interface{}{"create_requested", "starting", "active", "delete_requested", "deleting", "deleted"}))
	}
	return
}

// DecodeCluster decodes the Cluster instance encoded in resp body.
func (c *Client) DecodeCluster(resp *http.Response) (*Cluster, error) {
	var decoded Cluster
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// An cluster reesources object reference by object id (oid), and url (default view)
//
// Identifier: application/cluster.ref+json; view=default
type ClusterRef struct {
	// The cluster resources resource unique oid
	Oid string `form:"oid" json:"oid" xml:"oid"`
	// url of the collection that contains this object
	URL string `form:"url" json:"url" xml:"url"`
}

// Validate validates the ClusterRef media type instance.
func (mt *ClusterRef) Validate() (err error) {
	if mt.Oid == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "oid"))
	}
	if mt.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	return
}

// DecodeClusterRef decodes the ClusterRef instance encoded in resp body.
func (c *Client) DecodeClusterRef(resp *http.Response) (*ClusterRef, error) {
	var decoded ClusterRef
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Users and tennants of the system are represented as the type Project (default view)
//
// Identifier: application/namespace+json; view=default
type Namespace struct {
	// applications assoicated with namespace
	Applications ApplicationRefCollection `form:"applications" json:"applications" xml:"applications"`
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexadecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// system wide unique namespace name
	Name string `form:"name" json:"name" xml:"name"`
	// cluster resource assoicated with namespace
	Resources *ClusterRef `form:"resources" json:"resources" xml:"resources"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Namespace media type instance.
func (mt *Namespace) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}

	if mt.Resources == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "resources"))
	}
	if mt.Applications == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "applications"))
	}
	if err2 := mt.Applications.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	if utf8.RuneCountInString(mt.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, mt.Name, utf8.RuneCountInString(mt.Name), 2, true))
	}
	if mt.Resources != nil {
		if err2 := mt.Resources.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeNamespace decodes the Namespace instance encoded in resp body.
func (c *Client) DecodeNamespace(resp *http.Response) (*Namespace, error) {
	var decoded Namespace
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Users and tennants of the system are represented as the type Project (default view)
//
// Identifier: application/namespace.ref+json; view=default
type NamespaceRef struct {
	// The namespace resource unique oid
	Oid string `form:"oid" json:"oid" xml:"oid"`
	// url of the collection that contains this object
	URL string `form:"url" json:"url" xml:"url"`
}

// Validate validates the NamespaceRef media type instance.
func (mt *NamespaceRef) Validate() (err error) {
	if mt.Oid == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "oid"))
	}
	if mt.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	return
}

// DecodeNamespaceRef decodes the NamespaceRef instance encoded in resp body.
func (c *Client) DecodeNamespaceRef(resp *http.Response) (*NamespaceRef, error) {
	var decoded NamespaceRef
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// NamespaceRefCollection is the media type for an array of NamespaceRef (default view)
//
// Identifier: application/namespace.ref+json; type=collection; view=default
type NamespaceRefCollection []*NamespaceRef

// Validate validates the NamespaceRefCollection media type instance.
func (mt NamespaceRefCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeNamespaceRefCollection decodes the NamespaceRefCollection instance encoded in resp body.
func (c *Client) DecodeNamespaceRefCollection(resp *http.Response) (NamespaceRefCollection, error) {
	var decoded NamespaceRefCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// NamespaceCollection is the media type for an array of Namespace (default view)
//
// Identifier: application/namespace+json; type=collection; view=default
type NamespaceCollection []*Namespace

// Validate validates the NamespaceCollection media type instance.
func (mt NamespaceCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeNamespaceCollection decodes the NamespaceCollection instance encoded in resp body.
func (c *Client) DecodeNamespaceCollection(resp *http.Response) (NamespaceCollection, error) {
	var decoded NamespaceCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Users and tennants of the system are represented as the type Project (default view)
//
// Identifier: application/project+json; view=default
type Project struct {
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexadecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// name of project
	Name string `form:"name" json:"name" xml:"name"`
	// namespace assoications for this project
	Namespaces NamespaceRefCollection `form:"namespaces" json:"namespaces" xml:"namespaces"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Project media type instance.
func (mt *Project) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}

	if mt.Namespaces == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "namespaces"))
	}
	if utf8.RuneCountInString(mt.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, mt.Name, utf8.RuneCountInString(mt.Name), 2, true))
	}
	if err2 := mt.Namespaces.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	return
}

// DecodeProject decodes the Project instance encoded in resp body.
func (c *Client) DecodeProject(resp *http.Response) (*Project, error) {
	var decoded Project
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ProjectCollection is the media type for an array of Project (default view)
//
// Identifier: application/project+json; type=collection; view=default
type ProjectCollection []*Project

// Validate validates the ProjectCollection media type instance.
func (mt ProjectCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeProjectCollection decodes the ProjectCollection instance encoded in resp body.
func (c *Client) DecodeProjectCollection(resp *http.Response) (ProjectCollection, error) {
	var decoded ProjectCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}
