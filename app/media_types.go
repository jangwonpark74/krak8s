// Code generated by goagen v1.2.0-dirty, DO NOT EDIT.
//
// API "krak8s": Application Media Types
//
// Command:
// $ goagen
// --design=krak8s/design
// --out=$(GOPATH)/src/krak8s
// --version=v1.2.0-dirty

package app

import (
	"github.com/goadesign/goa"
	"time"
	"unicode/utf8"
)

// Application representation type (default view)
//
// Identifier: application/application+json; view=default
type Application struct {
	// generated resource unique id (8 character hexidecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// Application name
	Name   string `form:"name" json:"name" xml:"name"`
	Status *struct {
		// Last deployment time
		DeployedAt time.Time `form:"deployed_at" json:"deployed_at" xml:"deployed_at"`
		// Application specific notification / statuses / notes (if any)
		Notes *string `form:"notes,omitempty" json:"notes,omitempty" xml:"notes,omitempty"`
		// Deployment state
		State string `form:"state" json:"state" xml:"state"`
	} `form:"status" json:"status" xml:"status"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
	// Application version
	Version string `form:"version" json:"version" xml:"version"`
}

// Validate validates the Application media type instance.
func (mt *Application) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if mt.Version == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "version"))
	}
	if mt.Status == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "status"))
	}
	if mt.Status != nil {

		if mt.Status.State == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.status`, "state"))
		}
		if !(mt.Status.State == "UNKNOWN" || mt.Status.State == "DEPLOYED" || mt.Status.State == "DELETED" || mt.Status.State == "SUPERSEDED" || mt.Status.State == "FAILED" || mt.Status.State == "DELETING") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status.state`, mt.Status.State, []interface{}{"UNKNOWN", "DEPLOYED", "DELETED", "SUPERSEDED", "FAILED", "DELETING"}))
		}
	}
	return
}

// ApplicationCollection is the media type for an array of Application (default view)
//
// Identifier: application/application+json; type=collection; view=default
type ApplicationCollection []*Application

// Validate validates the ApplicationCollection media type instance.
func (mt ApplicationCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Cluster resource representation type (default view)
//
// Identifier: application/cluster+json; view=default
type Cluster struct {
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexidecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// Requested node pool size
	NodePoolSize int `form:"nodePoolSize" json:"nodePoolSize" xml:"nodePoolSize"`
	// Lifecycle state
	State string `form:"state" json:"state" xml:"state"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Cluster media type instance.
func (mt *Cluster) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if mt.State == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "state"))
	}
	if !(mt.State == "create_requested" || mt.State == "starting" || mt.State == "active" || mt.State == "delete_requested" || mt.State == "deleting" || mt.State == "deleted") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.state`, mt.State, []interface{}{"create_requested", "starting", "active", "delete_requested", "deleting", "deleted"}))
	}
	return
}

// Users and tennants of the system are represented as the type Project (default view)
//
// Identifier: application/namespace+json; view=default
type Namespace struct {
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexidecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// system wide unique namespace name
	Name string `form:"name" json:"name" xml:"name"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Namespace media type instance.
func (mt *Namespace) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}

	if utf8.RuneCountInString(mt.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, mt.Name, utf8.RuneCountInString(mt.Name), 2, true))
	}
	return
}

// Users and tennants of the system are represented as the type Project (default view)
//
// Identifier: application/project+json; view=default
type Project struct {
	Applications *struct {
		// generated resource unique id
		ID string `form:"id" json:"id" xml:"id"`
		// applications collection url
		URL string `form:"url" json:"url" xml:"url"`
	} `form:"applications,omitempty" json:"applications,omitempty" xml:"applications,omitempty"`
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// generated resource unique id (8 character hexidecimal value)
	ID string `form:"id" json:"id" xml:"id"`
	// name of project
	Name       string `form:"name" json:"name" xml:"name"`
	Namespaces *struct {
		// generated resource unique id
		ID string `form:"id" json:"id" xml:"id"`
		// namespaces collection url
		URL string `form:"url" json:"url" xml:"url"`
	} `form:"namespaces,omitempty" json:"namespaces,omitempty" xml:"namespaces,omitempty"`
	Resources *struct {
		// generated resource unique id
		ID string `form:"id" json:"id" xml:"id"`
		// resources object url
		URL string `form:"url" json:"url" xml:"url"`
	} `form:"resources,omitempty" json:"resources,omitempty" xml:"resources,omitempty"`
	// constant: object type
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Project media type instance.
func (mt *Project) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}

	if mt.Applications != nil {
		if mt.Applications.ID == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.applications`, "id"))
		}
		if mt.Applications.URL == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.applications`, "url"))
		}
	}
	if utf8.RuneCountInString(mt.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, mt.Name, utf8.RuneCountInString(mt.Name), 2, true))
	}
	if mt.Namespaces != nil {
		if mt.Namespaces.ID == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.namespaces`, "id"))
		}
		if mt.Namespaces.URL == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.namespaces`, "url"))
		}
	}
	if mt.Resources != nil {
		if mt.Resources.ID == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.resources`, "id"))
		}
		if mt.Resources.URL == "" {
			err = goa.MergeErrors(err, goa.MissingAttributeError(`response.resources`, "url"))
		}
	}
	return
}

// ProjectCollection is the media type for an array of Project (default view)
//
// Identifier: application/project+json; type=collection; view=default
type ProjectCollection []*Project

// Validate validates the ProjectCollection media type instance.
func (mt ProjectCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}
