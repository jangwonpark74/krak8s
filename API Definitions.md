# Overview
The terms REST and RESTful spark in the mind varying definitions for everyone who reads them. The following definitions are provided to avoid confusion.  These definitions may, or may not, comport with the canonical definition of REST, let alone even begin to argue what that concept is.  The purpose served here is to remove any uncertainty for users of this particular API. 

# Resource Operations
The only goal is to achieve consistent use within the protocol definition here. To aid in this consistency, especially with regard to related projects, this API supports the resource operation definitions described in the [Kubernetes API Specification](https://kubernetes.io/docs/api-reference/v1.7/#resource-operations).  

This simple approach uses a functional mapping between the standard Create, Read, Update, and Delete (CRUD) operations and HTTP methods.  The functional mapping of resource operations to HTTP verbs is defined as follows:
* Create - POST
* Read - GET
* Update - PUT (replace in whole) or PATCH (update in part)
* Delete - DELETE

In addition, the API supports all the standard protocol conventions with respect to the idempotency of actions related to HTTP Requests and caching of HTTP Responses. 

# API Specification
The API Specification for the project's master branch is available here: [Swagger.io Editor](https://editor.swagger.io/?url=https://raw.githubusercontent.com/samsung-cnct/krak8s/master/swagger/swagger.json#)

**IMPORTANT NOTE:** The only authoritative definition of the resources and endpoints defined for any instance of the API, as well as the methods that are supported for a given resource, is the OpenAPI (aka Swagger 2.0) definition generated by the running API Server itself.  The API Specification link above is provided for convenience, but it is the representation of the API design that is accessible on the master branch of this online repository **only**.

## Resources 
In an effort to keep this project as DRY as possible, the following is minimalist description of the resources defined for the interface.

The following are the major categories of resources administered by the API.

* OpenAPI - The OpenAPI (Swagger 2.0) specification for this interface
* Swagger - The Swagger 2.0 (OpenAPI) specification for this interface
* Projects Collection - The primary unit of isolation for users, tennant, teams, etc... 
  * Namespaces Collection - The project's namespace(s), e.g. "proj-dev", "prog-test", "prog-prod" 
  * Applications Collection - The namespace's installed applications
  * Cluster - The namespace's Kraken orchestrated Kubernetes cluster resources object 

## Order of Operations
There are two restriction on the ordering of operations for the API. 

1. The `namespace` resource *must* be created (POST) before a `cluster` resource can be created.  Any attempt to perform an operation on the `cluster` endpoint when no `namespace` endpoint is defined will return an error response code.

1. The `cluster` resource *must* be created (POST) before an `application` resource can be created.  Any attempt to perform an operation on the `application` endpoint when no `cluster` endpoint is defined will return an error response code.  While not strictly necessary, it is preferable to read the status of the `cluster` endpoint and check that the cluster resources are in an "active" state, as shown below before performing additional operations.  If the cluster resources are not ready when an application is deployed, then the create request will still be accepted however the application deployment may timeout (faile) and subsequently need to be resubmitted.
```
Status: 200 (Ok)
{
  "type": "cluster",
  "id": "de2760b1",
  "nodePoolSize": 3,
  "state": "create_requested"
  "created_at": "1988-11-12T15:18:46-08:00",
}
```

## Example Usage

The following example uses the commonly available `curl` command to create and retrieve objects from the API.  Note that in all the following examples the JSON output has been run through a formatter for improved readability.  The JSON pretty printing process is not shown here.

1. Create (POST) an initial project, then read (GET) it back
```
$ curl -XPOST -H "Content-Type: application/json" \
       -d '{"name":"acme"}' http://localhost:8080/v1/projects 
{
	"created_at": "2017-08-11T22:03:46.021222713-07:00",
	"id": "d1226f6a",
	"name": "acme",
	"namespaces": null,
	"type": "project"
}

# GET the projects collection
$ curl http://localhost:8080/v1/projects
[{
	"created_at": "2017-08-11T22:03:46.021222713-07:00",
	"id": "d1226f6a",
	"name": "acme",
	"namespaces": null,
	"type": "project"
}]

# Alternately - GET just the single project
$ curl http://localhost:8080/v1/projects/a0b4574a
{
	"created_at": "2017-08-11T22:03:46.021222713-07:00",
	"id": "d1226f6a",
	"name": "acme",
	"namespaces": null,
	"type": "project"
}
```
2. Create (POST) a namespace in the newly created project, and read (GET) it back.
```
$ curl -XPOST -H "Content-Type: application/json" \
       -d '{"name":"acme-prod"}' http://localhost:8080/v1/projects/d1226f6a/namespaces
{
	"applications": null,
	"created_at": "2017-08-11T22:04:48.613174018-07:00",
	"id": "20b5bac8",
	"name": "acme-prod",
	"resources": null,
	"type": "namespace"
}

# GET the namespaces collection
$ curl http://localhost:8080/v1/projects/d1226f6a/namespaces
[{
	"applications": null,
	"created_at": "2017-08-11T22:04:48.613174018-07:00",
	"id": "20b5bac8",
	"name": "acme-prod",
	"resources": null,
	"type": "namespace"
}]

# Alternately - GET just the single namespace
$ curl http://localhost:8080/v1/projects/d1226f6a/namespaces/20b5bac8
{
	"applications": null,
	"created_at": "2017-08-11T22:04:48.613174018-07:00",
	"id": "20b5bac8",
	"name": "acme-prod",
	"resources": null,
	"type": "namespace"
}
```
3. Create (POST) a cluster resources specification in the newly created namespace, and read (GET) it back.
```
$ curl -XPOST -H "Content-Type: application/json" \
       -d '{"namespace_id":"20b5bac8", "nodePoolSize": 7}' \
       http://localhost:8080/v1/projects/d1226f6a/cluster
{
	"created_at": "0001-01-01T00:00:00Z",
	"id": "c7454a66",
	"namespace_id": "20b5bac8",
	"nodePoolSize": 7,
	"state": "create_requested",
	"type": "Resource"
}

# GET the cluster resources specification
$ curl http://localhost:8080/v1/projects/d1226f6a/cluster/c7454a66
{
	"created_at": "0001-01-01T00:00:00Z",
	"id": "c7454a66",
	"namespace_id": "20b5bac8",
	"nodePoolSize": 7,
	"state": "create_requested",
	"type": "Resource"
}
```
4. Create (POST) an application in to the namespace in the project, and read (GET) it back.
```
$ curl -XPOST -H "Content-Type: application/json" \
       -d '{"name": "AcmeWidgetPipeline", "version": "v1.0.0-alpha.2", "namespace_id":"20b5bac8"}' \
       http://localhost:8080/v1/projects/d1226f6a/applications
{
	"id": "99bf7a79",
	"name": "AcmeWidgetPipeline",
	"namespace_id": "20b5bac8",
	"status": null,
	"type": "application",
	"version": "v1.0.0-alpha.2"
}

# GET the applications collection for the namespace
$ curl -XGET -H "Content-Type: application/json" \
       -d '{"namespaceid":"20b5bac8"}' http://localhost:8080/v1/projects/d1226f6a/applications
[{
	"id": "99bf7a79",
	"name": "AcmeWidgetPipeline",
	"namespace_id": "20b5bac8",
	"status": null,
	"type": "application",
	"version": "v1.0.0-alpha.2"
}]

# Alternately - GET just the single application
$ curl http://localhost:8080/v1/projects/d1226f6a/applications/99bf7a79
{
	"id": "99bf7a79",
	"name": "AcmeWidgetPipeline",
	"namespace_id": "20b5bac8",
	"status": null,
	"type": "application",
	"version": "v1.0.0-alpha.2"
}
```
5. Note that, as we've been creating objects in the API that have relationships with existing objects, those existing objects have been incrementally updated with references to the newly created elements.
```
# Repeat the GET on the project object
$ curl http://localhost:8080/v1/projects/d1226f6a
{
	"created_at": "2017-08-11T22:03:46.021222713-07:00",
	"id": "d1226f6a",
	"name": "acme",
	"namespaces": [{
		"oid": "20b5bac8",
		"url": "/v1/projects/d1226f6a/namespaces/20b5bac8"
	}],
	"type": "project"
}

# Repeat the GET on the namespace object
$ curl http://localhost:8080/v1/projects/d1226f6a/namespaces/20b5bac8
{
	"applications": [{
		"oid": "99bf7a79",
		"url": "/v1/projects/d1226f6a/applications/99bf7a79"
	}],
	"created_at": "2017-08-11T22:04:48.613174018-07:00",
	"id": "20b5bac8",
	"name": "acme-prod",
	"resources": {
		"oid": "c7454a66",
		"url": "/v1/projects/d1226f6a/cluster/c7454a66"
	},
	"type": "namespace"
}
```

## A Longer Example

The following example also uses `curl` commands to create and retrieve objects from the API.  This example doesn't try to demonstrate all of the functionality of various endpoints.  Rather, the goal here is to illustrate what **might** be a typical workflow for creating a couple of projects, their related resources, an application, and then taking down some (or all) of those resources.

Using a cluster named "Meteor", we'll create some constellation related projects.

1. There are three preparatory steps shown first
    1. Create the project `neptune`  
	2. Create a namespace for the project, `neptune-test`
	3. Create the cluster resources associated with this project/namespaces.
```
$ curl -XPOST -H "Content-Type: application/json" -d '{"name":"neptune"}' http: //localhost:8080/v1/projects
{
	"created_at": "2017-08-16T09:43:46.888464975-07:00",
	"id": "a901c92b",
	"name": "neptune",
	"namespaces": null,
	"type": "project"
}
$ curl -XPOST -H "Content-Type: application/json" -d '{"name":"neptune-test"}' http: //localhost:8080/v1/projects/a901c92b/namespaces
{
	"applications": null,
	"created_at": "2017-08-16T09:44:12.07355244-07:00",
	"id": "70271bbf",
	"name": "neptune-test",
	"resources": null,
	"type": "namespace"
}
$ curl -XPOST -H "Content-Type: application/json" -d '{"namespace_id":"70271bbf", "nodePoolSize": 3}' http: //localhost:8080/v1/projects/a901c92b/cluster
{
	"created_at": "2017-08-16T09:44:40.20165339-07:00",
	"id": "e74f17d7",
	"namespace_id": "70271bbf",
	"nodePoolSize": 3,
	"state": "create_requested",
	"type": "Resource",
	"updated_at": "0001-01-01T00:00:00Z"
}
```
2. This final step can take a significant amount of time.  It's not unusual for this to take anywhere from 5 to 15 minutes, sometimes less, almost never more.  As such, it is necessary to poll the newly created endpoint periodically to see it make the transition from either `"state": "create_requested"` or `"state": "starting"` to the desired ready `"state": "active"` - shown below.
```
$ curl http: //localhost:8080/v1/projects/a901c92b/cluster/e74f17d7
{
	"created_at": "2017-08-16T09:44:40.20165339-07:00",
	"id": "e74f17d7",
	"namespace_id": "70271bbf",
	"nodePoolSize": 3,
	"state": "active",
	"type": "Resource",
	"updated_at": "2017-08-16T09:50:11.049940314-07:00"
}
```

From the API servers log output we see that this operation took just over 5 minutes to complete, also noted in the difference between the crated and updated timestamps in the object itself.
```
I0816 09:50:11.049953   15111 runner.go:274] Queued task deleted: type: AddProject, name: neptune, namespace: neptune-test, queueing duration: 5m30.848282467s, running duration 5m30.846522554s
```
Everytime a physical change to the infrastructure of the cluster is requested, the persistent state of the cluster is reflected in both the clusters `config.yaml` file and the terraform manifest associated with the cluster.  For example, after running the sequence above successfully, the config file shows the delta between the current and backup versions of the file.
```
$ diff config.yaml config.yaml.1502901880 
530,541d529
<         - name: neptuneNodes
<           count: 3
<           kubeConfig: *meteorKube
<           containerConfig: *defaultDocker
<           osConfig: *defaultCoreOs
<           nodeConfig: 
<             << : *defaultAwsClusterNode
<             taints:
<               - key: node-role.kubernetes.io/neptune
<                 value: neptune
<                 effect: NoSchedule
<           keyPair: *meteorKeyPair
```

3. Another constellation is added to the cluster in similar fashion.
```
$ curl -XPOST -H "Content-Type: application/json" -d '{"name":"mars"}'
http: //localhost:8080/v1/projects
{
	"created_at": "2017-08-16T10:00:20.092785526-07:00",
	"id": "ca57d654",
	"name": "mars",
	"namespaces": null,
	"type": "project"
}
$ curl -XPOST -H "Content-Type: application/json" -d '{"name":"mars-production"}'
http: //localhost:8080/v1/projects/ca57d654/namespaces
{
	"applications": null,
	"created_at": "2017-08-16T10:01:02.179474746-07:00",
	"id": "84f70e67",
	"name": "mars-production",
	"resources": null,
	"type": "namespace"
}
$ curl -XPOST -H "Content-Type: application/json" -d '{"namespace_id":"84f70e67", "nodePoolSize": 3}'
http: //localhost:8080/v1/projects/ca57d654/cluster
{
	"created_at": "2017-08-16T10:01:28.436890214-07:00",
	"id": "55a9bd4e",
	"namespace_id": "84f70e67",
	"nodePoolSize": 3,
	"state": "create_requested",
	"type": "Resource",
	"updated_at": "0001-01-01T00:00:00Z"
}
$ curl http: //localhost:8080/v1/projects/ca57d654/cluster/55a9bd4e
{
	"created_at": "2017-08-16T10:01:28.436890214-07:00",
	"id": "55a9bd4e",
	"namespace_id": "84f70e67",
	"nodePoolSize": 3,
	"state": "starting",
	"type": "Resource",
	"updated_at": "2017-08-16T10:01:28.437887418-07:00"
}
$ curl http: //localhost:8080/v1/projects/ca57d654/cluster/55a9bd4e
{
	"created_at": "2017-08-16T10:01:28.436890214-07:00",
	"id": "55a9bd4e",
	"namespace_id": "84f70e67",
	"nodePoolSize": 3,
	"state": "starting",
	"type": "Resource",
	"updated_at": "2017-08-16T10:01:28.437887418-07:00"
}
$ curl http: //localhost:8080/v1/projects/ca57d654/cluster/55a9bd4e
{
	"created_at": "2017-08-16T10:01:28.436890214-07:00",
	"id": "55a9bd4e",
	"namespace_id": "84f70e67",
	"nodePoolSize": 3,
	"state": "active",
	"type": "Resource",
	"updated_at": "2017-08-16T10:14:03.033979445-07:00"
}
```
The last 4 curl commands show the resource's complete transition from `"create_requested"` to `"starting"` (repeated poll twice), and finally to `"active"`.

4. Bring up a MongoDB Application using the new Mars Production cluster resources.
```
curl -XPOST -H "Content-Type: application/json" -d '{ "name": "mongodb-replicaset", "registry": "quay.io/samsung_cnct", "set": "", "version": "", "namespace_id": "84f70e67"}'
http: //localhost:8080/v1/projects/ca57d654/applications
{
	"created_at": "2017-08-16T10:14:03.033981237-07:00",
	"id": "9f0d9890",
	"name": "mongodb-replicaset",
	"namespace_id": "84f70e67",
	"status": null,
	"type": "application",
	"updated_at": "0001-01-01T00:00:00Z",
	"version": ""
}
```
5. As it appears that the Neptune Test resources are not actually getting used, remove them from the cluster.
```
$ curl http: //localhost:8080/v1/projects/a901c92b/cluster/e74f17d7
{
	"created_at": "2017-08-16T09:44:40.20165339-07:00",
	"id": "e74f17d7",
	"namespace_id": "70271bbf",
	"nodePoolSize": 3,
	"state": "active",
	"type": "Resource",
	"updated_at": "2017-08-16T09:50:11.049940314-07:00"
}
$ curl -XDELETE http: //localhost:8080/v1/projects/a901c92b/cluster/e74f17d7
$ curl http: //localhost:8080/v1/projects/a901c92b/cluster/e74f17d7
{
	"created_at": "2017-08-16T09:44:40.20165339-07:00",
	"id": "e74f17d7",
	"namespace_id": "70271bbf",
	"nodePoolSize": 3,
	"state": "deleting",
	"type": "Resource",
	"updated_at": "2017-08-16T10:17:58.923457293-07:00"
}
$ curl http: //localhost:8080/v1/projects/a901c92b/cluster/e74f17d7
{
	"created_at": "2017-08-16T09:44:40.20165339-07:00",
	"id": "e74f17d7",
	"namespace_id": "70271bbf",
	"nodePoolSize": 3,
	"state": "deleted",
	"type": "Resource",
	"updated_at": "2017-08-16T10:21:58.712095513-07:00"
}
```
Much as the resource creation process has state transitions, so does releasing resources.  As shown above, the resources goes from `"active"` to `"deleting"` and finally to `"deleted"`.

At this point, the API record of the resource remains in place so that it can be queried to collect the final state, and possibly the timestamps, should that information be of interest.

To permanently remove the record, we delete the enclosing namespace.  
```
$ curl -XDELETE http://localhost:8080/v1/projects/f0fc2c78/namespaces/70271bbf
```
If there was no future need for the root project, the same effect can be achieved by deleting the base object, the project, if desired.  There is no need to delete all the associated elements first.
